import streamlit as st
import os
import shutil
import subprocess
import sys
import time
import pandas as pd
from datetime import datetime
#nothing shows in the app...these just load libraries

#streamlit --> makes the web app UI
#os --> interact with files/folders
#shutil --> copy/move files
#subprocess --> run external commands
#sys --> get Python executable
#time --> add delays
#pandas --> handle Excel files
#datetime --> format timestamps

# === Auto-start file server (optional) ===
def start_file_server():
#this defines a function named "start_file_server"
    try:
        folder_to_serve = r"C:\PN-RE-LAB"
        #sets the folder "C:\PN-RE-LAB" as the one that will be shared via the mini web server.
        port = 8502
        #chooses port 8502 for the local server
        #so the server will run at "http://localhost:8502" (or "http://<yourPC>:8502" on LAN)
        command = [sys.executable, "-m", "http.server", str(port), "--directory", folder_to_serve]
        #builds a command to start a built-in Python HTTP server:
        #sys.executable --> runs your current Python interpreter
        #-m http.server --> starts Python's mini web server
        #str(port) --> runs on port 8502
        #--directory folder_to_serve --> serves files from C:\PN-RE-LAB
        subprocess.Popen(command, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        #runs the command in the background (so it doesn't block Streamlit)
        #stdout=subprocess.DEVNULL --> hides normal messages
        #stderr=subprocess.DEVNULL --> hides error messages
        #so the user won't see any output here
        time.sleep(1)
        #waits 1 second to give the server time to start before the rest of the Streamlit app runs
    except Exception as e:
        st.warning(f"Failed to start file server: {e}")
    #if something goes wrong, Streamlit shows a yellow warning box with error message

start_file_server()
#calls the function immediately when Streamlit starts

#what happen for the user:
#No visible output if everything works fine
#But now, they can open a browser and go to:
#--> http://localhost:8502 (on the same PC)
#--> or http://<YourPCName>:8502 (on another PC in same LAN)
#They'll see a file browser like this:
#Example output in browser (auto-generated by Python's server)
#Directory listing for /C:/PN-RE-LAB
#EMPLOYEE_LIST.xlsx
#upload_log/
#archived/

# === Helpers ===
def human_size(num_bytes: int) -> str:
#takes an integer "num_bytes" (file size in raw bytes)
#returns a string (formatted size, e.g. "1.2 MB")
    for unit in ["B", "KB", "MB", "GB", "TB"]:
    #Goes through each unit, starting from bytes (B) up to terabytes (TB)
        if num_bytes < 1024.0:
            return f"{num_bytes:.1f} {unit}"
        #if the value is less than 1024, stop and return it with the current unit
        #example:
        #if "num_bytes = 512", --> "512.0 B"
        #if "num_bytes = 2048," --> too big, so divide by 1024 and continue
        num_bytes /= 1024.0
        #if too big, divide by 1024 to go to the next unit
        #Example:
        #2048 bytes / 1024 = 2.0 KB
    return f"{num_bytes:.1f} PB"
#if the loop finishes (size bigger than TB), return in petabytes(PB)

#Example outputs
#print(human_size(500)) #500.0 B
#print(human_size(2048)) #2.0 KB
#print(human_size(1048576)) #1.0 MB
#print(human_size(1073741824)) #1.0 GB
#print(human_size(1099511627776)) #1.0 TB

#Output
#500.0 B
#2.0 KB
#1.0 MB
#1.0 GB
#1.0 TB

def list_files_fast(folder: str):
#takes a folder path as input
#purpose: to list all files inside that folder (and subfolders) with some details
    files_list = []
    #this will store info about each file as a dictionary
    #example at this stage: "files_list = []"
    for root, _, files in os.walk(folder):
    #"os.walk(folder)" goes through every folder, subfolder, and files inside "folder"
    #"root" = current folder path
    #"_" = list of subholders (ignored here)
    #"files" = list of filenames in this folder
    #Output example for "C:\PN-RE-LAB\UPLOADS:"
    #root = "C:\\PN-RE-LAB\\UPLOADS\\TRH"
    #files = ["test1.xlsx", "test2.xlsx"]

        for file in files:
        #iterate through each file in the current folder
            try:
                path = os.path.join(root, file)
            #builds full file path, e.g.:
            #path = "C:\\PN-RE-LAB\\UPLOADS\\TRH\\test1.xlsx"
                stat = os.stat(path)
                #os.stat() gets metadata about the file, including:
                #st_size --> file size in bytes
                #st_mtime --> last modified timestamp
                #example:
                #stat.st_size = 2048
                #stat.st_mtime = 1695030000.0 #UNIX timestamp
                employee_folder = os.path.basename(os.path.dirnmae(path))
                #assumes file is under employee folder, e.g.:
                #path = "C:\\PN-RE-LAB\\UPLOADS\\TRH\\1000329829\\test1.xlsx"
                #os.path.dirname(path) -> "C:\\PN-RE-LAB\\UPLOADS\\TRH\\1000329829"
                #os.path.basename(...) -> "1000329829"
                #So employee_folder = "1000329829"
                files_list.append({
                    "name": file,
                    "path": path,
                    "size": stat.st_size,
                    "mtime": stat.st_mtime,
                    "employee": employee_folder
                })
                #adds a dictionary for this file:
                #"name": "test1.xlsx".
                #"path": "C:\\PN-RE-LAB\\UPLOADS\\TRH\\1000329829\\test1.xlsx",
                #"size": 2048,
                #"mtime": 1695030000.0,
                #"employee": 1000329829"
            except FileNotFoundError:
                continue
            #skips the file if it doesn't exist anymore (e.g., deleted while scanning)
    files_list.sort(key=lambda x: x["mtime"], reverse=True)
    #sorts the list most recently modified first
    #example after sorting:
    #[{"name": "test2.xlsx", "mtime": 1695040000.0}, {"name": "test1.xlsx","mtime": 1695030000.0}]
    return files_list
    #returns a list of dictionaries for all files in the folder (and subfolders) with their info
    #example output:
    #[
    #{
    #    "name": "test2.xlsx",
    #    "path": "C:\\PN-RE-LAB\\UPLOADS\\TRH\\1000329829\\test2.xlsx",
    #    "size": 3072
    #     "mtime": 1695040000.0,
    #     "employee": "1000329829"
    #},
    #{
    #    "name": "test1.xlsx",
    #     "path": "C:\\PN-RE-LAB\\UPLOADS\\TRH\\1000329829\\test1.xlsx",
    #     "size": 2048,
    #       "mtime": 1695030000.0,
    #       "employee": "1000329829"}
    #{
    #]

#this function scans a folder recursively
#collects file name, full path, size, last modified time, and employee folder
#returns a sorted list (most recent files first)
#used in the dashboard to show uploaded files in a log

def save_to_local(src_path, dst_folder):
#takes two arguments:
#src_path -> the source file path (where the file is now)
#dst_folder -> the destination folder (where we want to save it)
    os.makedirs(dst_folder, exists_ok=True)
    #creates the destination folder if it doesn't already exists
    #exists_ok=True -> prevents error if folder already exists
    #example
    #dst_folder = "C:\\PN-RE-LAB\\UPLOADS\\TRH"
    #If UPLOADS/TRH doesn't exist -> it will be created
    dst_path = os.path.join(dst_folder, os.path.basename(src_path))
    #os.path.basename(src_path) -> gets only the filename
    #Joins it with dst_folder to get the final save location
    #Example:
    #src_path = "C:\\Users\\Me\\Desktop\\report.xlsx"
    #dst_folder = "C:\\PN-RE-LAB\\UPLOADS\\TRH"
    #dst_path = "C:\\PN-RE-LAB\\UPLOADS\\TRH\\report.xlsx"
    try:
        if os.path.abspath(src_path) != os.path.abspath(dst_path):
            shutil.copy2(src_path, dst_path)
        return dst_path, True
    #Checks if source and destination are not the same file
    #(os.path.abspath) -> converts both to full absolute paths
    #If dirrent -> copies file with "shutil.copy2()" (preserves metadata like modified date)
    #Returns tuple (dst_path, True) -> meaning copy succeeded
    except shutil.SameFileError:
        return dst_path, False
    #if the source and destination are exactly the same file, it won't copy
    #Returns (dst_path, False) -> meaning no copy happened
    except Exception as e:
        return dst_path, str(e)
    #catches any other error(like permission denied, disk full, etc)
    #returns (dst_path, "error message")
    #ex:("C:\\PN-RE-LAB\\UPLOADS\\TRH\\report.xlsx", "Permission denied")
    #Example usage:
    #src = "C:\\Users\\Me\\Desktop\\report.xlsx"
    #dst = "C:\\PN-RE-LAB\\UPLOADS\\TRH"
    #print(save_to_local(src, dst))
    #possible outputs:
    #("C:\\PN-RE-LAB\\UPLOADS\\TRH\\report.xlsx", True) #Copied
    #("C:\\PN-RE-LAB\\UPLOADS\\TRH\\report.xlsx", False) #Same file, no copy
    #("C:\\PN-RE-LAB\\UPLOADS\\TRH\\report.xlsx", "Permission denied") #Error
    
    
# === Load Employee List from Shared File (robust) ===
EMPLOYEE_LIST_PATH = r"C:\PN-RE-LAB\EMPLOYEE_LIST.xlsx"
#Hardcodes the Excel file path where the employee list is stored
#The Excel must have at least 2 columns:
#--> Employee #
#--> Name

def load_employee_list():
    abs_path = os.path.abspath(EMPLOYEE_LIST_PATH)
#Converts the path to absolute form so Python knows exactly where to find the file
    if not os.path.exists(abs_path):
        st.error(f"Employee list file not found at {abs_path}")
        st.stop()
    #if the file does not exist --> shows red error message in Streamlit and stops the app
    #Output in UI:
    #Employee list file not found at C:\PN-RE-LAB\EMPLOYEE_LIST.xlsx
    try:
        df = pd.read_excel(abs_path, dtype=str)
        #reads the Excel into a Pandas DataFrame
        #"dtype=str" ensures all values are read as strings (important for employee IDs like "00123" that Excel might convert to numbers)
        if 'Employee #' not in df.columns or 'Name' not in df.columns:
            st.error("Excel must have columns: 'Employee #' and 'Name'")
            st.stop()
        #if the Excel is missing either Employee # or Name column -> shows error and stops
        #Output in UI:
        #Excel must have columns: 'Employee #' and 'Name'
        return df
        #if everything is fine -> returns the DataFrame with employee list
    except Exception as e:
        st.error(f"Failed to read employee list: {e}")
        st.stop()
    #if reading fails(e.g. corrupted Excel, permission denied) -> shows error message
    #Output in UI:
    #Failed to read employee list: <error message>

employee_df = load_employee_list()
employee_ids = employee_df['Employee #'].tolist()
#calls the function to actually load the employee list
#saves the DataFrame into "employee_df"
#Extracts the list of employee IDs into "employee_ids"
#Example DataFrame (employee_df):
#Employee #                Name
#1001                     Alice Lee
#1002                     Bob Tan
#Example list (employee_ids):
#["1001", "1002"]

# === Employee Login ===
if "authenticated" not in st.session_state:
    st.session_state["authenticated"] = False
    st.session_state["employee_id"] = None
#Streamlit uses "st.session_state" to remember data between app interactions.
#This block ensures two things exist when the app first starts:
#"authenticated -> set to "False" (user not logged in yet)
#"employee_id" -> set to "None" (no user assigned yet)
#Output: Nothing visible to the user (just internal memory setup)

def check_employee_id():
#defines a helper function to check whether the user is logged in
    if not st.session_state["authenticated"]:
    #if the user has not logged in yet -> show the login form
    #if already logged in (True) -> skip straight to returning "True"
        with st.form("login_form"):
        #creates a form block so multiple widgets are grouped together.
        #Inside this form:
        #-> A text input field
        #-> A login button
            emp_id = st.text_input("Enter Employee #")
            #shows a textbox asking the user to type their Employee #
            #Output in UI:
            #Enter Employee #: [______________]
            submitted = st.form_submit_button("Login")
            #creates a "Login" button inside the form
            #when clicked -> return "True" in "submitted"
            #Output in UI:
            #[ Login ]
            if submitted:
            #Runs only when the user clicks Login
                if emp_id in employee_ids:
                #checks if the entered Employee # exists in the "employee_ids" list
                    st.session_state["authenticated"] = True
                    st.session_state["employee_id"] = emp_id
                    employee_name = employee_df.loc[employee_df['Employee #']==emp_id, 'Name'.values[0]]
                    st.success(f"Welcome {employee_name}")
                    st.rerun()
                #sets the session as logged in.
                #stores which employee ID logged in
                #Looks up their Name in the DataFrame
                #Shows a green success message:
                # Welcome Alice Lee
                #"st.rerun()" reloads the app so the login form disappears and the user sees the main app instead
                else:
                    st.error("Invalid Employee")
                #shows a red error message
                # "Invalid Employee"
        return False
        #If login failed -> return "False" (user not logged in)
        #If already logged in -> return "True"
    return True

if not check_employee_id():
    st.stop()
#Calls the login check function
#If it returns "False" (user not logged in yet) -> stop running the rest of the app until they log in

#App starts
#User sees a textbox -> "Enter Employee #" and a Login button
#If they type "1001" and it exists in Excel -> login succeeds -> page refresh -> "Welcome Alice Lee"
#If they type something wrong -> "Invalid Employee"

# === Config Constants ===
SHARED_UPLOAD_FOLDER = r"C:\PN-RE-LAB\UPLOADS"
LOCAL_SAVE_FOLDER   = os.path.join(SHARED_UPLOAD_FOLDER, "DOWNLOADS")
os.makedirs(LOCAL_SAVE_FOLDER, exist_ok=True)
#What it does:
#Defines a shared folder "UPLOADS"
#Creates a "DOWNLOADS" folder inside "UPLOADS"
#Ensures the folder exists (creates it if missing)

#Example (folder structure after running):
#C:\PN-RE-LAB\
#  |----UPLOADS\
#  |      |---DOWNLOADS\

SPOTFIRE_MI_URLS = {
    "TRH": "https://spotfiremypn.wdc.com/spotfire/wp/analysis?file=/ADHOC/RELIABILITY/TRH",
    "HACT": "https://spotfiremypn.wdc.com/spotfire/wp/analysis?file=/ADHOC/RELIABILITY/HACT",
    "HEAD WEAR": "https://spotfiremypn.wdc.com/spotfire/wp/analysis?file=/ADHOC/RELIABILITY/HeadWear",
}
#What it does:
#Creates a dictionary (SPOTFIRE_MI_URLS) mapping test names (TRH, HACT, HEAD WEAR) to their Spotfire dashboard links

#How it looks in Streamlit UI(example dropdown):
#Select MI Test:
#[ TRH ]
#[ HACT ]
#[ HEAD WEAR ]
#When a user selects, the corresponding Spotfire URL can be opened

SPOTFIRE_CHEMLAB_URLS = {
    "GCMS": "https://spotfiremypn.wdc.com/spotfire/wp/analysis?file=/ADHOC/RELIABILITY/gcms",
    "LCQTOF": "https://spotfiremypn.wdc.com/spotfire/wp/analysis?file=/ADHOC/RELIABILITY/lcqtof",
}
#What it does:
#Creates another dictionary for Chemlab tests (GCMS, LCQTOF) with their Spotfire links
#How it looks in Streamlit UI (example dropdown):
#Select Chemlab Test:
#[ GCMS ]
#[ LCQTOF ]
#Again, clicking a test opens its Spotfire dashboard

#SHARED_UPLOAD_FOLDER and LOCAL_SAVE_FOLDER define and create the storage folders
#SPOTFIRE_MI_URLS and SPOTFIRE_CHEMLAB_URLS are lookup tables for test dashboards



mi_tests = list(SPOTFIRE_MI_URLS.keys())
cl_tests = list(SPOTFIRE_CHEMLAB_URLS.keys())
#SPOTFIRE_MI_URLS and SPOTFIRE_CHEMLAB_URLS are dictionaries you defined earlier
#".keys()" pulls out just the keys (e.g., "TRH", "HACT", "HEAD WEAR" for MI)
#Wrapping in "list(...)" makes them into Python lists
#Example output:
# -> mi_tests = ["TRH", "HACT", "HEAD WEAR"]
# -> cl_tests = ["GCMS", "LCQTOF"]

# === Tabs ===
tabs = ["📁 MI Upload", "📁 Chemlab Upload", "📈 View Spotfire Dashboard", "📋 Uploaded Log"]
#This defines the tab names that will show up in the Streamlit app navigation dropdown
#The emojis make it visually clear what each tab is about
selected_tab = st.selectbox("🗭 Navigate", tabs, label_visibility="collapsed")
#This creates a dropdown menu in Streamlit
#The user will see the options from the "tabs" list and can select one
#"label_visibility="collapsed"" hides the label "Navigate" (the dropdown shows only the options)
#Example output in the UI: a dropdown with
#-> MI Upload
#-> Chemlab Upload
#-> View Spotfire Dashboard
#-> Uploaded Log
#The variable "selected_tab" will hold whichever tab the user picks (e.g., "MI Upload")

# === Upload Section ===
def handle_upload(test_type, tests_list):
#test_type : either "MI" or "Chemlab" depending on which tab the user is in
#tests_list : the list of tests for that category (e.g., ["TRH", "HACT", "HEAD WEAR"] for MI)
    st.subheader(f"🛠️ Upload {test_type} Test File")
    selected_test = st.selectbox(f"Select {test_type} Test", tests_list)
    file = st.file_uploader("Upload Excel File", type=["xlsx"])
    #A subheader like "Upload MI Test File"
    #A dropdown (st.selectbox) to choose a test (e.g., TRH, HACT)
    #A file uploader (st.file_uploader) where user can drag-drop or browse for an ".xlsx"
    if file:
        emp_id = st.session_state["employee_id"]
        employee_name = employee_df.loc[employee_df['Employee #']==emp_id, 'Name'].values[0]

        #Gets the employee ID from the login session
        #Looks up the employee's name in the Excel list
        #This ensures files are saved under the correct person

        user_folder = os.path.join(SHARED_UPLOAD_FOLDER, selected_test, emp_id)
        spotfire_folder = os.path.join(SHARED_UPLOAD_FOLDER, "Spotfire", selected_test)
        local_folder = os.path.join(LOCAL_SAVE_FOLDER, selected_test, emp_id)
        os.makedirs(user_folder, exist_ok=True)
        os.makedirs(spotfire_folder, exist_ok=True)
        os.makedirs(local_folder, exist_ok=True)

        #Builds 3 storage paths:
        #user_folder: for this employee's uploads
        #Example: C:\PN-RE-LAB\UPLOADS\TRH\12345
        #spotfire_folder: a shared folder where Spotfire can access the file
        #Example: C:\PN-RE-LAB\UPLOADS\Spotfire\TRH
        #local_folder: personal "downloads" for this employee
        #Example: C:\PN-RE-LAB\UPLOADS\DOWNLOADS\TRH\12345

        #What happens: If these folders don't exists, they get created

        # Save upload
        stream_path = os.path.join(user_folder, file.name)
        with open(stream_path, "wb") as f:
            f.write(file.read())

        #writes the uploaded file into the employee's folder
        #Example: C:\PN-RE-LAB\UPLOADS\TRH\12345\report.xlsx

        # Copy to Spotfire
        shutil.copy2(stream_path, os.path.join(spotfire_folder, file.name))
        #Makes a copy in the Spotfire folder so dashboards can read it

        # Copy to local DOWNLOADS
        local_path, saved = save_to_local(stream_path, local_folder)
        #calls your helper save_to_local -> copies file into DOWNLOADS folder
        #Returns (path, status) where "status" is True (saved), False (already exists), or error message

        st.success(f"💾 File saved in `{stream_path}`")
        st.success(f"📂 Copied to Spotfire folder: `{spotfire_folder}`")
        if saved is True:
            st.success(f"💾 Saved to Downloads: `{local_path}`")
        elif saved is False:
            st.info(f"💾 Already exists in Downloads: `{local_path}`")
        else:
            st.error(f"❌ Failed saving to Downloads: {saved}")

        #"File saved in C:\PN-RE-LAB\UPLOADS\TRH\12345\report.xlsx"
        #"Copied to Spotfire folder"
        #or "i" message about Downloads copy

        st.download_button("📥 Download This File", data=open(stream_path, "rb").read(), file_name=file.name)
        #what user sees:
        #A download button that lets them immediately re-download the uploaded file

#User chooses test & uploads file
#File goes into 3 places (employee folder, Spotfire folder, Downloads)
#User gets confirmation messages + download button

# === Uploaded Log Section ===
def render_uploaded_log(test_list, title):
#test_list: list of test names (e.g., ["TRH", "HACT", "HEAD WEAR"])
#title: a heading string to show (e.g., "MI Uploaded Files")
    st.markdown(f"### {title}")
    #User sees: A header like ### MI Uploaded Files
    container = st.container()
    page_size = st.slider("Rows per page", 5, 50, 20, 5, key=f"{title}_slider")  
    #st.container() groups UI elements
    #st.slider lets the user pick how many files to show at once (between 5 and 50)
    #-> Default: 20 rows per page
    #User sees: A slider bar labeled Rows per page

    for test in test_list:
        test_folder = os.path.join(SHARED_UPLOAD_FOLDER, test)
        os.makedirs(test_folder, exist_ok=True)
        files = list_files_fast(test_folder)
        total = len(files)
    #For each test (e.g., "TRH") -> find its folder in "UPLOADS"
    #Ensure the folder exists
    #list_files_fast returns metadata for all files
    #total = number of files
        with container.expander(f"📁 {test} — {total} file(s)", expanded=False):
        #User sees:
        #A collapsible section like:
        #-> TRH - 12 file(s) (default collapsed)
            if total == 0:
                st.info("No files in this test yet.")
                continue
            #User sees: An info box if no files are found
            page_files = files[:page_size]
            #only take the first N files(N = page_size)
            #(Note: This is not full pagination yet, just trimming the list)
            for f in page_files:
                emp_id = f["employee"]
                employee_name = employee_df.loc[employee_df['Employee #']==emp_id, 'Name'].values[0] if emp_id in employee_ids else emp_id
            #Get employee ID from file path
            #Look up full name from employee list if available
                c1, c2, c3 = st.columns([0.4, 0.3, 0.3])
                with c1: st.write(f"{f['name']} (by {employee_name})")
                with c2: st.write(f"Size: {human_size(f['size'])}")
                with c3:
                    try:
                        with open(f["path"], "rb") as file_data:
                            st.download_button("📥", data=file_data.read(), file_name=f['name'])
                    except Exception as e:
                        st.error(f"Download failed: {e}")

                #User sees (per file, in 3 columns):
                # 1.Filename + uploader name
                # Example: "report.xlsx (by John Tan)"
                # 2.File size (formatted nicely, e.g., 2.3 MB)
                # Download button to get the file
                # If download fails -> show an error message
#This function creates a log of uploaded files for each test type, grouped into expandable sections, with file details and download buttons 

# === Main Tabs ===
if selected_tab == "📁 MI Upload":
    handle_upload("MI", mi_tests)
#If user chooses MI Upload from the dropdown ->
#It calls handle_upload("MI", mi_tests) -> user gets the upload UI for MI tests.
#Output: Upload form (choose MI test, upload Excel file, save, download back)
elif selected_tab == "📁 Chemlab Upload":
    handle_upload("Chemlab", cl_tests)
#if user chooses Chemlab Upload ->
#Shows upload UI for Chemlab tests instead
elif selected_tab == "📈 View Spotfire Dashboard":
    st.subheader("📈 Spotfire Dashboards")
    category = st.radio("Choose Category", ["MI", "Chemlab"], horizontal=True)
#Shows a subheader
#Adds a radio button to pick between MI or Chemlab dashboards
#User sees:
#Spotfire Dashboards
# [ MI ] [ Chemlab ]
    tests = mi_tests if category == "MI" else cl_tests
    urls = SPOTFIRE_MI_URLS if category == "MI" else SPOTFIRE_CHEMLAB_URLS
    #Chooses the correct list of tests & Spotfire URLs depending on category
    selected = st.selectbox("Select Dashboard", tests)
    #Dropdown to pick which specific dashboard (e.g., TRH, HACT, GCMS)
    #User sees: A dropdown menu with test names
    st.markdown(f'<a href="{urls[selected]}" target="_blank">Open {selected} Dashboard in Spotfire</a>', unsafe_allow_html=True)
    #Creates a clickable link that opens the Spotfire dashboard in a new browser tab
    #User sees:
    #Open TRH Dashboard in Spotfire(blue hyperlink)
elif selected_tab == "📋 Uploaded Log":
    render_uploaded_log(mi_tests, "🛠 MI Tests")
    st.markdown("---")
    render_uploaded_log(cl_tests, "🧪 Chemlab Tests")
    #if user selects Uploaded Log ->
    #Shows logs for MI tests and Chemlab tests
    #A horizontal line (---) separates them
    #User sees:
    #Two sections:
    #MI Tests (expandable logs with files + download buttons)
    #Chemlab Tests (same structure)

st.markdown("<hr><div class='footer'>📘 Made with passion by RE PN LAB 2025</div>", unsafe_allow_html=True)
#Adds a horizontal rule + a footer note at the bottom
#User sees:
#-> -------------------------
#-> Made with passion by RE PN LAB 2025
                     